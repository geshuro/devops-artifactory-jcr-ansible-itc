global:
  versions: {}
  customCertificates:
    enabled: false


initContainerImage: releases-docker.jfrog.io/alpine:3.13.1

logger:
  image:
    registry: releases-docker.jfrog.io
    repository: busybox
    tag: 1.32.1

artifactory:
  artifactory:
    name: artifactory
    image:
      registry: releases-docker.jfrog.io
      repository: jfrog/artifactory-pro
      pullPolicy: IfNotPresent

    openMetrics:
      enabled: false

    migration:
      enabled: false
    
    customInitContainersBegin: |
    #  - name: "custom-setup"
    #    image: "{{ .Values.initContainerImage }}"
    #    imagePullPolicy: "{{ .Values.artifactory.image.pullPolicy }}"
    #    command:
    #      - 'sh'
    #      - '-c'
    #      - 'touch {{ .Values.artifactory.persistence.mountPath }}/example-custom-setup'
    #    volumeMounts:
    #      - mountPath: "{{ .Values.artifactory.persistence.mountPath }}"
    #        name: artifactory-volume

    ## Add custom init containers execution after predefined init containers
    customInitContainers: |
    #  - name: "custom-systemyaml-setup"
    #    image: "{{ .Values.initContainerImage }}"
    #    imagePullPolicy: "{{ .Values.artifactory.image.pullPolicy }}"
    #    command:
    #      - 'sh'
    #      - '-c'
    #      - 'wget -O {{ .Values.artifactory.persistence.mountPath }}/etc/system.yaml https://<repo-url>/systemyaml'
    #    volumeMounts:
    #      - mountPath: "{{ .Values.artifactory.persistence.mountPath }}"
    #        name: artifactory-volume

    ## Add custom sidecar containers
    # - The provided example uses a custom volume (customVolumes)
    # - The provided example shows running container as root (id 0)
    customSidecarContainers: |
    #  - name: "sidecar-list-etc"
    #    image: "{{ .Values.initContainerImage }}"
    #    imagePullPolicy: "{{ .Values.artifactory.image.pullPolicy }}"
    #    securityContext:
    #      runAsUser: 0
    #      fsGroup: 0
    #    command:
    #      - 'sh'
    #      - '-c'
    #      - 'sh /scripts/script.sh'
    #    volumeMounts:
    #      - mountPath: "{{ .Values.artifactory.persistence.mountPath }}"
    #        name: artifactory-volume
    #      - mountPath: "/scripts/script.sh"
    #        name: custom-script
    #        subPath: script.sh
    #    resources:
    #      requests:
    #        memory: "32Mi"
    #        cpu: "50m"
    #      limits:
    #        memory: "128Mi"
    #        cpu: "100m"

    ## Add custom volumes
    customVolumes: |
    #  - name: custom-script
    #    configMap:
    #      name: custom-script

    ## Add custom volumesMounts
    customVolumeMounts: |
    #  - name: custom-script
    #    mountPath: "/scripts/script.sh"
    #    subPath: script.sh
    #  - name: posthook-start
    #    mountPath: "/scripts/posthoook-start.sh"
    #    subPath: posthoook-start.sh
    #  - name: prehook-start
    #    mountPath: "/scripts/prehook-start.sh"
    #    subPath: prehook-start.sh

    # Add custom persistent volume mounts - Available for the pod
    # If skipPrepareContainer is set to true , this will skip the prepare-custom-persistent-volume init container
    customPersistentPodVolumeClaim: {}
    #  name:
    #  mountPath:
    #  accessModes:
    #   - "-"
    #  size:
    #  storageClassName:
    #  skipPrepareContainer: false

    # Add custom persistent volume mounts - Available to the entire namespace
    customPersistentVolumeClaim: {}
    #  name:
    #  mountPath:
    #  accessModes:
    #   - "-"
    #  size:
    #  storageClassName:

    ## Artifactory license.
    license:
      ## licenseKey is the license key in plain text. Use either this or the license.secret setting
      licenseKey:
      ## If artifactory.license.secret is passed, it will be mounted as
      ## ARTIFACTORY_HOME/etc/artifactory.lic and loaded at run time.
      secret:
      ## The dataKey should be the name of the secret data key created.
      dataKey:

    ## Create configMap with artifactory.config.import.xml and security.import.xml and pass name of configMap in following parameter
    configMapName:

    # Add any list of configmaps to Artifactory
    configMaps: |
    #  posthook-start.sh: |-
    #    echo "This is a post start script"
    #  posthook-end.sh: |-
    #    echo "This is a post end script"

    ## List of secrets for Artifactory user plugins.
    ## One Secret per plugin's files.
    userPluginSecrets:
    #  - archive-old-artifacts
    #  - build-cleanup
    #  - webhook
    #  - '{{ template "my-chart.fullname" . }}'

    ## Artifactory requires a unique master key.
    ## You can generate one with the command: "openssl rand -hex 32"
    ## An initial one is auto generated by Artifactory on first startup.
    # masterKey: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
    ## Alternatively, you can use a pre-existing secret with a key called master-key by specifying masterKeySecretName
    # masterKeySecretName:

    ## Join Key to connect other services to Artifactory
    ## IMPORTANT: Setting this value overrides the existing joinKey
    ## IMPORTANT: You should NOT use the example joinKey for a production deployment!
    # joinKey: EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
    ## Alternatively, you can use a pre-existing secret with a key called join-key by specifying joinKeySecretName
    # joinKeySecretName:

    # Add custom secrets - secret per file
    customSecrets:
    #  - name: custom-secret
    #    key: custom-secret.yaml
    #    data: >
    #      custom_secret_config:
    #        parameter1: value1
    #        parameter2: value2
    #  - name: custom-secret2
    #    key: custom-secret2.config
    #    data: |
    #      here the custom secret 2 config

    ## If false, all service console logs will not redirect to a common console.log
    consoleLog: false

    binarystore:
      enabled: true

    ## admin allows to set the password for the default admin user.
    ## See: https://www.jfrog.com/confluence/display/JFROG/Users+and+Groups#UsersandGroups-RecreatingtheDefaultAdminUserrecreate
    admin:
      ip: "127.0.0.1"
      username: "admin"
      password:
      secret:
      dataKey:

    ## Extra pre-start command to install JDBC driver for MySql/MariaDb/Oracle
    # preStartCommand: "mkdir -p /opt/jfrog/artifactory/var/bootstrap/artifactory/tomcat/lib; cd /opt/jfrog/artifactory/var/bootstrap/artifactory/tomcat/lib && wget -O /opt/jfrog/artifactory/var/bootstrap/artifactory/tomcat/lib/mysql-connector-java-5.1.41.jar https://jcenter.bintray.com/mysql/mysql-connector-java/5.1.41/mysql-connector-java-5.1.41.jar"
    ## Extra post-start command to run extra commands after container starts
    # postStartCommand:

    ## Extra environment variables that can be used to tune Artifactory to your needs.
    ## Uncomment and set value as needed
    extraEnvironmentVariables:
    # - name: SERVER_XML_ARTIFACTORY_PORT
    #   value: "8081"
    # - name: SERVER_XML_ARTIFACTORY_MAX_THREADS
    #   value: "200"
    # - name: SERVER_XML_ACCESS_MAX_THREADS
    #   value: "50"
    # - name: SERVER_XML_ARTIFACTORY_EXTRA_CONFIG
    #   value: ""
    # - name: SERVER_XML_ACCESS_EXTRA_CONFIG
    #   value: ""
    # - name: SERVER_XML_EXTRA_CONNECTOR
    #   value: ""
    # - name: DB_POOL_MAX_ACTIVE
    #   value: "100"
    # - name: DB_POOL_MAX_IDLE
    #   value: "10"
    # - name: MY_SECRET_ENV_VAR
    #   valueFrom:
    #     secretKeyRef:
    #       name: my-secret-name
    #       key: my-secret-key

    systemYaml: |
      shared:
        logging:
          consoleLog:
            enabled: {{ .Values.artifactory.consoleLog }}
        extraJavaOpts: >
          -Dartifactory.access.client.max.connections={{ .Values.access.tomcat.connector.maxThreads }}
        {{- with .Values.artifactory.javaOpts }}
          -Dartifactory.async.corePoolSize={{ .corePoolSize }}
        {{- if .xms }}
          -Xms{{ .xms }}
        {{- end }}
        {{- if .xmx }}
          -Xmx{{ .xmx }}
        {{- end }}
        {{- if .jmx.enabled }}
          -Dcom.sun.management.jmxremote
          -Dcom.sun.management.jmxremote.port={{ .jmx.port }}
          -Dcom.sun.management.jmxremote.rmi.port={{ .jmx.port }}
          -Dcom.sun.management.jmxremote.ssl={{ .jmx.ssl }}
        {{- if .jmx.host }}
          -Djava.rmi.server.hostname={{ tpl .jmx.host $ }}
        {{- else }}
          -Djava.rmi.server.hostname={{ template "artifactory.fullname" $ }}
        {{- end }}
        {{- if .jmx.authenticate }}
          -Dcom.sun.management.jmxremote.authenticate=true
          -Dcom.sun.management.jmxremote.access.file={{ .jmx.accessFile }}
          -Dcom.sun.management.jmxremote.password.file={{ .jmx.passwordFile }}
        {{- else }}
          -Dcom.sun.management.jmxremote.authenticate=false
        {{- end }}
        {{- end }}
        {{- if .other }}
          {{ .other }}
        {{- end }}
        {{- end }}
        {{- if or .Values.database.type .Values.postgresql.enabled }}
        database:
          {{- if .Values.postgresql.enabled }}
          type: postgresql
          url: "jdbc:postgresql://{{ .Release.Name }}-postgresql:{{ .Values.postgresql.service.port }}/{{ .Values.postgresql.postgresqlDatabase }}"
          driver: org.postgresql.Driver
          username: "{{ .Values.postgresql.postgresqlUsername }}"
          {{- else }}
          type: "{{ .Values.database.type }}"
          driver: "{{ .Values.database.driver }}"
          {{- end }}
        {{- end }}
      artifactory:
      {{- if .Values.artifactory.openMetrics }}
        metrics:
          enabled: {{ .Values.artifactory.openMetrics.enabled }}
      {{- end }}
        database:
          maxOpenConnections: {{ .Values.artifactory.database.maxOpenConnections }}
        tomcat:
          connector:
            maxThreads: {{ .Values.artifactory.tomcat.connector.maxThreads }}
            extraConfig: {{ .Values.artifactory.tomcat.connector.extraConfig }}
      frontend:
        session:
          timeMinutes: {{ .Values.frontend.session.timeoutMinutes | quote }}
      access:
        database:
          maxOpenConnections: {{ .Values.access.database.maxOpenConnections }}
        tomcat:
          connector:
            maxThreads: {{ .Values.access.tomcat.connector.maxThreads }}
            extraConfig: {{ .Values.access.tomcat.connector.extraConfig }}
      metadata:
        database:
          maxOpenConnections: {{ .Values.metadata.database.maxOpenConnections }}
      {{- if .Values.artifactory.replicator.enabled }}
      replicator:
        enabled: true
      {{- end }}

    annotations: {}

    service:
      name: artifactory
      type: ClusterIP
      ## For supporting whitelist on the Artifactory service (useful if setting service.type=LoadBalancer)
      ## Set this to a list of IP CIDR ranges
      ## Example: loadBalancerSourceRanges: ['10.10.10.5/32', '10.11.10.5/32']
      ## or pass from helm command line
      ## Example: helm install ... --set nginx.service.loadBalancerSourceRanges='{10.10.10.5/32,10.11.10.5/32}'
      loadBalancerSourceRanges: []
      annotations: {}

    ## The following setting are to configure a dedicated Ingress object for Replicator service
    replicator:
      enabled: false
      ingress:
        name:
        hosts: []
        annotations: {}
        # kubernetes.io/ingress.class: nginx
        # nginx.ingress.kubernetes.io/proxy-buffering: "off"
        # nginx.ingress.kubernetes.io/configuration-snippet: |
        #   chunked_transfer_encoding on;
        tls: []
        #  Secrets must be manually created in the namespace.
        # - hosts:
        #   - artifactory.domain.example
        #   secretName: chart-example-tls-secret
      ## When replicator is enabled and want to use tracker feature, trackerIngress.enabled flag should be set to true
      ## Please refer - https://www.jfrog.com/confluence/display/JFROG/JFrog+Peer-to-Peer+%28P2P%29+Downloads
      trackerIngress:
        enabled: false
        name:
        hosts: []
        annotations: {}
        # kubernetes.io/ingress.class: nginx
        # nginx.ingress.kubernetes.io/proxy-buffering: "off"
        # nginx.ingress.kubernetes.io/configuration-snippet: |
        #   chunked_transfer_encoding on;
        tls: []
        #  Secrets must be manually created in the namespace.
        # - hosts:
        #   - artifactory.domain.example
        #   secretName: chart-example-tls-secret

    ## IMPORTANT: If overriding artifactory.internalPort:
    ## DO NOT use port lower than 1024 as Artifactory runs as non-root and cannot bind to ports lower than 1024!
    externalPort: 8082
    internalPort: 8082
    externalArtifactoryPort: 8081
    internalArtifactoryPort: 8081
    uid: 1030
    gid: 1030
    terminationGracePeriodSeconds: 30

    ## By default, the Artifactory StatefulSet is created with a securityContext that sets the `runAsUser` and the `fsGroup` to the `artifactory.uid` value.
    ## If you want to disable the securityContext for the Artifactory StatefulSet, set this tag to false
    setSecurityContext: true

    ## The following settings are to configure the frequency of the liveness and readiness probes
    livenessProbe:
      enabled: true
      path: /router/api/v1/system/health
      initialDelaySeconds: 0
      failureThreshold: 10
      timeoutSeconds: 5
      periodSeconds: 10
      successThreshold: 1

    readinessProbe:
      enabled: true
      path: /router/api/v1/system/health
      initialDelaySeconds: 0
      failureThreshold: 10
      timeoutSeconds: 5
      periodSeconds: 10
      successThreshold: 1

    startupProbe:
      enabled: true
      path: /router/api/v1/system/health
      initialDelaySeconds: 30
      failureThreshold: 60
      periodSeconds: 5
      timeoutSeconds: 5

    persistence:
      mountPath: "/var/opt/jfrog/artifactory"
      enabled: false
      ## A manually managed Persistent Volume and Claim
      ## Requires persistence.enabled: true
      ## If defined, PVC must be created manually before volume will be bound
      # existingClaim:

      accessMode: ReadWriteOnce
      ## Storage default size. Should be increased for production deployments.
      size: 20Gi

      ## Use a custom Secret to be mounted as your binarystore.xml
      ## NOTE: This will ignore all settings below that make up binarystore.xml
      customBinarystoreXmlSecret:
      ## Cache default size. Should be increased for production deployments.
      maxCacheSize: 5000000000
      cacheProviderDir: cache

      ## Set the persistence storage type. This will apply the matching binarystore.xml to Artifactory config
      ## Supported types are:
      ## file-system (default)
      ## nfs
      ## google-storage
      ## aws-s3
      ## aws-s3-v3
      ## azure-blob
      type: file-system

      ## Use binarystoreXml to provide a custom binarystore.xml
      ## This can be a template or hardcoded.
      binarystoreXml: |
        {{- if eq .Values.artifactory.persistence.type "file-system" -}}
        <!-- File system filestore -->
        <config version="v1">
            <chain>
              {{- if .Values.artifactory.persistence.fileSystem.cache.enabled }}
                <provider id="cache-fs" type="cache-fs">
              {{- end }}
                    <provider id="file-system" type="file-system"/>
              {{- if .Values.artifactory.persistence.fileSystem.cache.enabled }}
                </provider>
              {{- end }}
            </chain>

          {{- if .Values.artifactory.persistence.fileSystem.cache.enabled }}
            <provider id="cache-fs" type="cache-fs">
                <maxCacheSize>{{ .Values.artifactory.persistence.maxCacheSize }}</maxCacheSize>
                <cacheProviderDir>{{ .Values.artifactory.persistence.cacheProviderDir }}</cacheProviderDir>
            </provider>
          {{- end }}
        </config>
        {{- end }}
        {{- if eq .Values.artifactory.persistence.type "google-storage" }}
        <!-- Google storage -->
        <config version="2">
            <chain>
                <provider id="cache-fs" type="cache-fs">
                    <provider id="eventual" type="eventual">
                        <provider id="retry" type="retry">
                            {{- if .Values.artifactory.persistence.googleStorage.gcpServiceAccount.enabled }}
                            <provider id="google-storage-v2" type="google-storage-v2"/>
                            {{- else }}
                            <provider id="google-storage" type="google-storage"/>
                            {{- end }}
                        </provider>
                    </provider>
                </provider>
            </chain>

            <!-- Set max cache-fs size -->
            <provider id="cache-fs" type="cache-fs">
                <maxCacheSize>{{ .Values.artifactory.persistence.maxCacheSize }}</maxCacheSize>
                <cacheProviderDir>{{ .Values.artifactory.persistence.cacheProviderDir }}</cacheProviderDir>
            </provider>

            <provider id="file-system" type="file-system">
                <fileStoreDir>{{ .Values.artifactory.persistence.mountPath }}/data/filestore</fileStoreDir>
                <tempDir>/tmp</tempDir>
            </provider>

            {{- if .Values.artifactory.persistence.googleStorage.gcpServiceAccount.enabled }}
            <provider id="google-storage-v2" type="google-storage-v2">
                <useInstanceCredentials>false</useInstanceCredentials>
            {{- else }}
            <provider id="google-storage" type="google-storage">
                <identity>{{ .Values.artifactory.persistence.googleStorage.identity }}</identity>
                <credential>{{ .Values.artifactory.persistence.googleStorage.credential }}</credential>
            {{- end }}
                <providerId>google-cloud-storage</providerId>
                <endpoint>{{ .Values.artifactory.persistence.googleStorage.endpoint }}</endpoint>
                <httpsOnly>{{ .Values.artifactory.persistence.googleStorage.httpsOnly }}</httpsOnly>
                <bucketName>{{ .Values.artifactory.persistence.googleStorage.bucketName }}</bucketName>
                <path>{{ .Values.artifactory.persistence.googleStorage.path }}</path>
                <bucketExists>{{ .Values.artifactory.persistence.googleStorage.bucketExists }}</bucketExists>
            </provider>
        </config>
        {{- end }}
        {{- if eq .Values.artifactory.persistence.type "aws-s3-v3" }}
        <!-- AWS S3 V3 -->
        <config version="2">
            <chain>
                <provider id="cache-fs" type="cache-fs">
                    <provider id="eventual" type="eventual">
                        <provider id="retry" type="retry">
                            <provider id="s3-storage-v3" type="s3-storage-v3"/>
                        </provider>
                    </provider>
                </provider>
            </chain>

            <!-- Set max cache-fs size -->
            <provider id="cache-fs" type="cache-fs">
                <maxCacheSize>{{ .Values.artifactory.persistence.maxCacheSize }}</maxCacheSize>
                <cacheProviderDir>{{ .Values.artifactory.persistence.cacheProviderDir }}</cacheProviderDir>
            </provider>

          {{- with .Values.artifactory.persistence.awsS3V3 }}
            <provider id="s3-storage-v3" type="s3-storage-v3">
                <testConnection>{{ .testConnection }}</testConnection>
              {{- if .identity }}
                <identity>{{ .identity }}</identity>
              {{- end }}
              {{- if .credential }}
                <credential>{{ .credential }}</credential>
              {{- end }}
                <region>{{ .region }}</region>
                <bucketName>{{ .bucketName }}</bucketName>
                <path>{{ .path }}</path>
                <endpoint>{{ .endpoint }}</endpoint>
              {{- with .maxConnections }}
                <maxConnections>{{ . }}</maxConnections>
              {{- end }}
              {{- with .kmsServerSideEncryptionKeyId }}
                <kmsServerSideEncryptionKeyId>{{ . }}</kmsServerSideEncryptionKeyId>
              {{- end }}
              {{- with .kmsKeyRegion }}
                <kmsKeyRegion>{{ . }}</kmsKeyRegion>
              {{- end }}
              {{- with .kmsCryptoMode }}
                <kmsCryptoMode>{{ . }}</kmsCryptoMode>
              {{- end }}
              {{- if .useInstanceCredentials }}
                <useInstanceCredentials>true</useInstanceCredentials>
              {{- else }}
                <useInstanceCredentials>false</useInstanceCredentials>
              {{- end }}
                <usePresigning>{{ .usePresigning }}</usePresigning>
                <signatureExpirySeconds>{{ .signatureExpirySeconds }}</signatureExpirySeconds>
              {{- with .cloudFrontDomainName }}
                <cloudFrontDomainName>{{ . }}</cloudFrontDomainName>
              {{- end }}
              {{- with .cloudFrontKeyPairId }}
                <cloudFrontKeyPairId>{{ .cloudFrontKeyPairId }}</cloudFrontKeyPairId>
              {{- end }}
              {{- with .cloudFrontPrivateKey }}
                <cloudFrontPrivateKey>{{ . }}</cloudFrontPrivateKey>
              {{- end }}
              {{- with .enableSignedUrlRedirect }}
                <enableSignedUrlRedirect>{{ . }}</enableSignedUrlRedirect>
              {{- end }}
              {{- with .enablePathStyleAccess }}
                <enablePathStyleAccess>{{ . }}</enablePathStyleAccess>
              {{- end }}
            </provider>
          {{- end }}
        </config>
        {{- end }}

        {{- if eq .Values.artifactory.persistence.type "aws-s3" }}
        <!-- AWS S3 -->
        <config version="2">
            <chain> <!--template="s3"-->
                <provider id="cache-fs" type="cache-fs">
                    <provider id="eventual" type="eventual">
                        <provider id="retry-s3" type="retry">
                            <provider id="s3" type="s3"/>
                        </provider>
                    </provider>
                </provider>
            </chain>

            <!-- Set max cache-fs size -->
            <provider id="cache-fs" type="cache-fs">
                <maxCacheSize>{{ .Values.artifactory.persistence.maxCacheSize }}</maxCacheSize>
                <cacheProviderDir>{{ .Values.artifactory.persistence.cacheProviderDir }}</cacheProviderDir>
            </provider>

            <provider id="s3" type="s3">
                <endpoint>{{ .Values.artifactory.persistence.awsS3.endpoint }}</endpoint>
            {{- if .Values.artifactory.persistence.awsS3.roleName }}
                <roleName>{{ .Values.artifactory.persistence.awsS3.roleName }}</roleName>
                <refreshCredentials>true</refreshCredentials>
            {{- else }}
                <refreshCredentials>{{ .Values.artifactory.persistence.awsS3.refreshCredentials }}</refreshCredentials>
            {{- end }}
                <s3AwsVersion>{{ .Values.artifactory.persistence.awsS3.s3AwsVersion }}</s3AwsVersion>
                <testConnection>{{ .Values.artifactory.persistence.awsS3.testConnection }}</testConnection>
                <httpsOnly>{{ .Values.artifactory.persistence.awsS3.httpsOnly }}</httpsOnly>
                <region>{{ .Values.artifactory.persistence.awsS3.region }}</region>
                <bucketName>{{ .Values.artifactory.persistence.awsS3.bucketName }}</bucketName>
            {{- if .Values.artifactory.persistence.awsS3.identity }}
                <identity>{{ .Values.artifactory.persistence.awsS3.identity }}</identity>
            {{- end }}
            {{- if .Values.artifactory.persistence.awsS3.credential }}
                <credential>{{ .Values.artifactory.persistence.awsS3.credential }}</credential>
            {{- end }}
                <path>{{ .Values.artifactory.persistence.awsS3.path }}</path>
            {{- range $key, $value := .Values.artifactory.persistence.awsS3.properties }}
                <property name="{{ $key }}" value="{{ $value }}"/>
            {{- end }}
            </provider>
        </config>
        {{- end }}
        {{- if eq .Values.artifactory.persistence.type "azure-blob" }}
        <!-- Azure Blob Storage -->
        <config version="2">
            <chain> <!--template="azure-blob-storage"-->
                <provider id="cache-fs" type="cache-fs">
                    <provider id="eventual" type="eventual">
                        <provider id="retry-azure-blob-storage" type="retry">
                            <provider id="azure-blob-storage" type="azure-blob-storage"/>
                        </provider>
                    </provider>
                </provider>
            </chain>

            <!-- Set max cache-fs size -->
            <provider id="cache-fs" type="cache-fs">
                <maxCacheSize>{{ .Values.artifactory.persistence.maxCacheSize }}</maxCacheSize>
                <cacheProviderDir>{{ .Values.artifactory.persistence.cacheProviderDir }}</cacheProviderDir>
            </provider>

            <provider id="azure-blob-storage" type="azure-blob-storage">
                <accountName>{{ .Values.artifactory.persistence.azureBlob.accountName }}</accountName>
                <accountKey>{{ .Values.artifactory.persistence.azureBlob.accountKey }}</accountKey>
                <endpoint>{{ .Values.artifactory.persistence.azureBlob.endpoint }}</endpoint>
                <containerName>{{ .Values.artifactory.persistence.azureBlob.containerName }}</containerName>
                <multiPartLimit>{{ .Values.artifactory.persistence.azureBlob.multiPartLimit }}</multiPartLimit>
                <multipartElementSize>{{ .Values.artifactory.persistence.azureBlob.multipartElementSize }}</multipartElementSize>
                <testConnection>{{ .Values.artifactory.persistence.azureBlob.testConnection }}</testConnection>
            </provider>
        </config>
        {{- end }}

      ## For artifactory.persistence.type nfs
      ## If using NFS as the shared storage, you must have a running NFS server that is accessible by your Kubernetes
      ## cluster nodes.
      ## Need to have the following set
      nfs:
        # Must pass actual IP of NFS server with '--set For artifactory.persistence.nfs.ip=${NFS_IP}'
        ip:
        haDataMount: "/data"
        haBackupMount: "/backup"
        dataDir: "/var/opt/jfrog/artifactory"
        backupDir: "/var/opt/jfrog/artifactory-backup"
        capacity: 200Gi

      ## For artifactory.persistence.type file-system
      fileSystem:
        cache:
          enabled: false

      ## For artifactory.persistence.type google-storage
      googleStorage:
        ## When using GCP buckets as your binary store (Available with enterprise license only)
        gcpServiceAccount:
          enabled: false
          ## Use either an existing secret prepared in advance or put the config (replace the content) in the values
          ## ref: https://github.com/jfrog/charts/blob/master/stable/artifactory-ha/README.md#google-storage
          # customSecretName:
          # config: |
          #   {
          #      "type": "service_account",
          #      "project_id": "<project_id>",
          #      "private_key_id": "?????",
          #      "private_key": "-----BEGIN PRIVATE KEY-----\n????????==\n-----END PRIVATE KEY-----\n",
          #      "client_email": "???@j<project_id>.iam.gserviceaccount.com",
          #      "client_id": "???????",
          #      "auth_uri": "https://accounts.google.com/o/oauth2/auth",
          #      "token_uri": "https://oauth2.googleapis.com/token",
          #      "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
          #      "client_x509_cert_url": "https://www.googleapis.com/robot/v1....."
          #   }
        endpoint: commondatastorage.googleapis.com
        httpsOnly: false
        # Set a unique bucket name
        bucketName: "artifactory-gcp"
        identity:
        credential:
        path: "artifactory/filestore"
        bucketExists: false

      ## For artifactory.persistence.type aws-s3-v3
      awsS3V3:
        testConnection: false
        identity:
        credential:
        region:
        bucketName: artifactory-aws
        path: artifactory/filestore
        endpoint:
        maxConnections: 50
        kmsServerSideEncryptionKeyId:
        kmsKeyRegion:
        kmsCryptoMode:
        useInstanceCredentials: true
        usePresigning: false
        signatureExpirySeconds: 300
        cloudFrontDomainName:
        cloudFrontKeyPairId:
        cloudFrontPrivateKey:
        enableSignedUrlRedirect: false
        enablePathStyleAccess: false

      ## For artifactory.persistence.type aws-s3
      ## IMPORTANT: Make sure S3 `endpoint` and `region` match! See https://docs.aws.amazon.com/general/latest/gr/rande.html
      awsS3:
        # Set a unique bucket name
        bucketName: "artifactory-aws"
        endpoint:
        region:
        roleName:
        identity:
        credential:
        path: "artifactory/filestore"
        refreshCredentials: true
        httpsOnly: true
        testConnection: false
        s3AwsVersion: AWS4-HMAC-SHA256
        ## Additional properties to set on the s3 provider
        properties: {}
        #  httpclient.max-connections: 100
      ## For artifactory.persistence.type azure-blob
      azureBlob:
        accountName:
        accountKey:
        endpoint:
        containerName:
        multiPartLimit: 100000000
        multipartElementSize: 50000000
        testConnection: false
      ## artifactory data Persistent Volume Storage Class
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
      # storageClassName: "-"
      ## Annotations for the Persistent Volume Claim
      annotations: {}
    ## Uncomment the following resources definitions or pass them from command line
    ## to control the cpu and memory resources allocated by the Kubernetes cluster
    resources: {}
    #  requests:
    #    memory: "1Gi"
    #    cpu: "500m"
    #  limits:
    #    memory: "2Gi"
    #    cpu: "1"
    ## The following Java options are passed to the java process running Artifactory.
    ## You should set them according to the resources set above
    javaOpts:
    # xms: "1g"
    # xmx: "2g"
      jmx:
        enabled: false
        port: 9010
        host:
        ssl: false
        # When authenticate is true, accessFile and passwordFile are required
        authenticate: false
        accessFile:
        passwordFile:
      corePoolSize: 8
    # other: ""

    nodeSelector: {}

    tolerations: []

    affinity: {}

    ssh:
      enabled: false
      internalPort: 1339
      externalPort: 1339


  # Nginx
  nginx:
    enabled: true
    kind: Deployment
    name: nginx
    labels: {}
    replicaCount: 1
    uid: 104
    gid: 107
    image:
      registry: releases-docker.jfrog.io
      repository: jfrog/nginx-artifactory-pro
      pullPolicy: IfNotPresent

    service:
      type: NodePort
      ssloffload: false
      externalTrafficPolicy: Cluster

  postgresql:
    enabled: false

  database:
    type: postgresql
    driver: org.postgresql.Driver
    url: "jdbc:postgresql://10.36.9.102:6432/artifactory?socketTimeout=1500"
    user: devops
    password: devops2022